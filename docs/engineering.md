# 工程化

## 模块化

### CommonJS

Nodejs 中使用 CommonJS 规范，规定了一个文件就是一个模块，模块可以多次加载，但是只会在第一次加载时运行一次，会将运行以后的结果进行**缓存**，以后加载只会去读取缓存。要想模块再次运行，需要清除缓存。

另外需要注意的点则是 CommonJS 模块导出的值是一个**拷贝**，可以把这个拷贝当作是函数中的传参，对于基本类型，会复制出来一个值，而对于引用类型，则拷贝的是值的引用。因此对于 CommonJS 导出的值，如果是基础值，模块内部改变了改基础值，也不会影响到模块外面，但如果是引用类型，模块内部的修改是会影响到外部的。

最后的关注点则是 CommonJS 模块是**同步加载**的，需要等到前面的模块加载完毕以后，才会加载后面的模块。

### AMD

使用`define`定义模块，使用`require`来加载模块，遵循此规范的代表：`require.js`。

AMD 用于浏览器环境，模块可以进行非同步加载，也可以根据需要**动态加载**。

### CMD

CMD 规范整合了 CommonJS 和 AMD 规范，用于浏览器端。模块是异步加载的，使用的时候才会去加载。遵循此规范的代表：`Sea.js`。

CMD 和 AMD 的定义模块、加载模块的方法有所不同。

### ES Module

ES Module 是浏览器端的模块化规范，也是未来的浏览器的模块标准。ES Module 是**静态化**的，是在**编译**时就能确定模块的依赖关系，所以可以用来做静态分析，判断哪些模块没有使用，通过 tree shaking 来去掉这些 dead code。

ES Module 和 CommonJS 最重要的区别就是 ES Module 导出的是值的引用，而 CommonJS 则是值的拷贝。这里引用的意思就是无论导出的值是什么类型，模块内部修改都会影响到模块外部。另外 ES Module 是编译时输出，而 CommonJS 则是运行时加载。

## Webpack

## Babel
