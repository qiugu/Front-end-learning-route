# 浏览器概览

![browser](./images/broswer_process.png)

## 浏览器内核

* Webkit(Safari)
* Trident(IE)
* Gecko(Firefox)
* Konqueror(KHTML引擎)
* Blink(Chrome、Opera)

## 浏览器的组成

* `界面控件` - 除浏览器主窗口外的其他部分，包括地址栏，前进后退按钮等都属于浏览器的界面控件
* `浏览器引擎` - 将用户界面的指令传递给渲染引擎
* `渲染引擎` - 负责解析HTML显示在浏览器主窗口
* `网络请求` - 用户网络请求，例如HTTP请求等
* `UI后端` - 绘制基本的窗口小部件
* `JS解释器` - 解释和执行JS代码
* `数据存储` - 持久层，如sessionStorage和localStorage及浏览器内置的数据库

## 浏览器中的进程

1. 渲染进程（谷歌浏览器中会开启多个渲染进程，但是根据打开的新页面判断是否同一协议，同一域名，是的话则复用渲染进程）
2. 浏览器主进程（负责用户交互，子进程管理以及文件存储功能）
3. GPU进程
4. 插件进程
5. 网络进程

> **谷歌浏览器正在走向面向服务的架构升级**

## 从输入URL到页面展示

![browser](https://static001.geekbang.org/resource/image/92/5d/92d73c75308e50d5c06ad44612bcb45d.png)

[点击查看具体流程](https://zhuanlan.zhihu.com/p/133906695)

- 浏览器进程从输入地址判断输入的内容是一个关键词还是一个URL地址，如果是关键词就会以默认的搜索引擎去搜索，否则的话，则会去对这个URL地址发起请求。
- 网络进程查找本地缓存中是否存在请求资源，如果存在直接返回资源给浏览器进程，否则发起DNS解析，获取域名对应的IP地址。如果请求协议是HTTPS，则还需要建立TLS连接。
- 建立TCP连接，进行三次握手。浏览器端构建请求行、请求头以及请求体。服务器响应请求，返回响应信息。网络进程开始解析响应信息，如果发现返回的状态码是301、302，则会从响应头中的Location字段获取重定向的地址，再次发起新的HTTP或HTTPS请求。**注意响应头信息中返回`content-type: octet-stream`，显示字节流类型，浏览器会把请求交给下载管理器，下载该资源**
- 浏览器进程将网络进程中获取的HTML信息提交给渲染进程，也就是所谓的发起**提交文档**的消息

## 浏览器的渲染过程

1. 解析HTML元素和文本节点，此时`document.readyState = 'loading'`。
2. 遇到外部link的CSS文件，浏览器会另外创建线程进行解析，所以外部CSS文件不会阻塞页面解析，但是会阻塞页面渲染。
3. 遇到外部的script脚本，如果没有async，defer属性，则会阻塞文档加载，等待脚本加载完成后继续解析文档；如果脚本有async，defer属性，浏览器会另外创建线程来加载脚本，对于async属性的脚本，加载完成后会立即执行。
4. 遇到img、video等资源，先正常解析DOM结构，浏览器会异步加载src指向的资源，然后继续解析文档。
5. DOM解析完之后，`document.readyState = 'interactive'`，此时defer属性的脚本开始顺序执行，执行完毕后触发了DOMContentLoaded事件，标志着程序执行从同步脚本执行阶段转换为事件驱动阶段。
6. async属性脚本加载完就会执行，不论是在HTML解析阶段还是在DOMContentLoaded之后执行，async属性脚本会阻塞load事件，当所有的async脚本执行完毕，以及img等资源加载完毕，`document.readyState = 'complete'`，window对象会触发load事件。

### 从浏览器绘制页面的过程来看

1. 解析HTML元素生成DOM树
2. 解析CSS、样式计算，生成styleSheets对象
3. 进行布局计算，生成布局树，也就是所谓的`Layout`
4. 对布局树进行分层，生成图层树
5. 为图层生成绘制列表，交给合成线程
6. 合成线程将图层转成图块，在光栅化线程池中将图块转换成位图
7. 合成线程发送绘图命令DrawQuad给浏览器进程
8. 浏览器进程根据DrawQuad消息生成页面，并显示到显示器上

### 回流（reflow）和重绘（repaint)

* 回流（reflow）：就是页面元素布局发生变化，浏览器需要重新回到渲染之前的状态重新计算
* 重绘（repaint）：当元素节点的自身不影响布局的属性，如背景色、字体颜色、边框颜色等发生改变时会触发重绘

> 触发回流一定会触发重绘，但是重绘却不一定会触发回流

### 性能影响

* 回流的代价比重绘更高
* 现代浏览器会对频繁的回流和重绘操作进行优化，即会将所有的回流或重绘的操作放入一个队列，然后进行一起操作，避免多次进行回流和重绘

## 浏览器缓存

* 强缓存
* 协商缓存
* 本地缓存localStorage和sessionStorage

## 浏览器兼容性问题

可以参考这篇文章[浏览器兼容性问题解决方案 · 总结](https://juejin.im/post/59a3f2fe6fb9a0249471cbb4)

## v8的垃圾回收机制

主要分为`新生代`和`老生代`空间。新生代存放那些经常变化的对象，老生代存放那些一直存在不变的对象。

新生代中的垃圾回收算法是`Scavenge`算法。新生代也分为两个空间，一个FORM，一个是TO，一般声明一个变量都会存放在FROM中，当进行垃圾回收的时候，FROM中还存在着使用的对象，则将其复制到TO空间中，然后清除FROM中所有的对象，最后将TO空间变成FROM，FROM空间再变成TO空间。

所以`Scavenge`算法就是复制两个空间，并进行互换，所以该算法会浪费一半的空间用于复制和交换。

当对象已经经过一次`Scavenge`算法，或者是TO空间使用占比超过了`25%`，那么就会进行`对象晋升`。所谓对象晋升就是将新生代中对象移动到老生代空间中。

由于老生代空间中的对象都是长期存活的对象，因此`Scavenge`算法不适用与老生代空间，老生代空间使用的算法就是`标记-清除`和`标记整理`算法。理解起来很简单，就是将老生代空间中的所有对象进行标记，一旦进行回收的时候，发现某个对象没有标记，那么就将其清除。因为不同的对象在内存中占据的空间是分散的，因此这样清理会出现`内存碎片`，而内存碎片会导致遇到一些大对象的时候，空间不足无法分配。因此这里又使用了标记整理算法，就是将之前标记的对象移到内存的另一端，然后清除剩下所有的空间，这样内存中的对象都集中在一端，就不会出现碎片的情况了。

老生代空间中存储着大量的存活对象，因此其数量十分庞大，当进行标记的时候，需要遍历空间中的所有对象，耗时特别长，导致浏览器无法响应js的任务。因此又引入了`增量标记`的概念，即将一次遍历的内存，改为多次分批标记，标记完一次之后停下来将执行权还给js线程，然后等待下一次执行标记会从上次标记的地方继续开始执行，这么做就不会导致浏览器执行长任务的时候卡顿无法响应js主线程。

## 其他

* 判断浏览器类型通过使用浏览器内置对象navigator的useAgent属性
* 浏览器桌面通知Notification

## 参考链接

* [浏览器渲染基本原理解析](https://mp.weixin.qq.com/s/njwpsI-5T2mewPYjNef0jA)
* [浏览器的回流与重绘](https://juejin.im/post/5a9923e9518825558251c96a)
* [JavaScript判断桌面浏览器和移动浏览器](https://github.com/XavierXuV5/Check-Browser)
* [H5 notification浏览器桌面通知](https://juejin.im/post/5c6df433f265da2de80f5eda)
* [浏览器的工作原理：新式网络浏览器幕后揭秘](https://www.html5rocks.com/zh/tutorials/internals/howbrowserswork/)

